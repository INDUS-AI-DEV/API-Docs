import React, {useState} from 'react';
import DocsLayout, {MethodBadge} from '@site/src/components/DocsLayout/DocsLayout';
import CodeBlock from '@theme/CodeBlock';

import styles from './api.module.css';

const TTS_BASE_URL = 'https://<host>';

const sharedPayload = `{
  "text": "string",
  "voice": "tara",
  "output_format": "pcm",
  "response_format": "pcm",
  "stream": false,
  "language": "en",
  "temperature": 0.6,
  "max_tokens": 1800,
  "top_p": 0.8,
  "repetition_penalty": 1.1,
  "max_words_per_chunk": 15,
  "chunk_overlap_words": 0,
  "bitrate": 128
}`;

const validationError = `{
  "detail": [
    {
      "loc": ["string", 0],
      "msg": "string",
      "type": "string"
    }
  ]
}`;

const sharedInputs = [
  {name: 'text', type: 'string', defaultValue: '-', description: 'Text to convert into speech. Required.'},
  {name: 'voice', type: 'string', defaultValue: 'tara', description: 'Voice model identifier.'},
  {name: 'output_format', type: 'string', defaultValue: 'pcm', description: 'Encoding generated by the service (for example pcm, mp3, wav).'},
  {name: 'response_format', type: 'string', defaultValue: 'pcm', description: 'Container format returned to the client.'},
  {name: 'stream', type: 'boolean', defaultValue: 'false', description: 'Enable streaming responses when supported.'},
  {name: 'language', type: 'string', defaultValue: 'en', description: 'ISO language code for the provided text.'},
  {name: 'temperature', type: 'number', defaultValue: '0.6', description: 'Controls variation in speech delivery.'},
  {name: 'max_tokens', type: 'integer', defaultValue: '1800', description: 'Token budget for synthesis.'},
  {name: 'top_p', type: 'number', defaultValue: '0.8', description: 'Nucleus sampling parameter that tunes variation.'},
  {name: 'repetition_penalty', type: 'number', defaultValue: '1.1', description: 'Values above 1 discourage repetition.'},
  {name: 'max_words_per_chunk', type: 'integer', defaultValue: '15', description: 'Chunk size used during streaming.'},
  {name: 'chunk_overlap_words', type: 'integer', defaultValue: '0', description: 'Word overlap between adjacent chunks.'},
  {name: 'bitrate', type: 'integer', defaultValue: '128', description: 'Target bitrate (kbps) if supported by the format.'},
];

const endpoints = [
  {
    anchor: 'tts-post-v1-audio-speech',
    method: 'POST',
    path: '/v1/audio/speech',
    title: 'Synthesize Speech',
    description:
      'Primary text-to-speech endpoint. Returns audio bytes immediately and supports low-latency streaming.',
    notes: [
      'Submit the shared JSON payload as the request body.',
      'Set stream: true to receive chunked audio when your client supports streaming.',
    ],
    inputs: sharedInputs,
    outputs: [
      {name: '200 OK', type: 'binary audio', defaultValue: '-', description: 'Audio bytes in the requested response_format.'},
      {name: '422 Validation Error', type: 'application/json', defaultValue: '-', description: 'Validation failure. Inspect detail array.'},
    ],
    examples: [
      {label: '422 Validation Error', language: 'json', code: validationError},
    ],
  },
  {
    anchor: 'tts-post-v1-audio-speech-file',
    method: 'POST',
    path: '/v1/audio/speech/file',
    title: 'Synthesize Speech File',
    description:
      'Generates a base64 encoded audio file alongside duration, size, and processing metrics.',
    notes: [
      'Streaming is not supported. Always request with stream: false.',
      'Response metadata helps you track storage, duration, and processing time.',
    ],
    inputs: sharedInputs,
    outputs: [
      {name: '200 OK', type: 'application/json', defaultValue: '-', description: 'Metadata and base64 encoded audio file contents.'},
      {name: '422 Validation Error', type: 'application/json', defaultValue: '-', description: 'Validation failure. Inspect detail array.'},
    ],
    examples: [
      {
        label: '200 OK',
        language: 'json',
        code: `{
  "request_id": "string",
  "text": "string",
  "voice": "string",
  "output_format": "string",
  "duration_seconds": 0,
  "size_bytes": 0,
  "audio": "<base64 string>",
  "processing_time_ms": 0,
  "stream": false
}`,
      },
      {label: '422 Validation Error', language: 'json', code: validationError},
    ],
  },
  {
    anchor: 'tts-post-v1-audio-speech-preview',
    method: 'POST',
    path: '/v1/audio/speech/preview',
    title: 'Speech Preview',
    description:
      'Returns a descriptive summary of how text will be chunked and scored before generating audio. Useful for estimating usage and costs.',
    notes: [
      'Request payload matches the shared schema.',
      'Response is a human-readable string describing chunk boundaries.',
    ],
    inputs: sharedInputs,
    outputs: [
      {name: '200 OK', type: 'text/plain', defaultValue: '-', description: 'Preview string describing chunking decisions.'},
      {name: '422 Validation Error', type: 'application/json', defaultValue: '-', description: 'Validation failure. Inspect detail array.'},
    ],
    examples: [
      {label: '200 OK', language: 'text', code: 'Chunk 1: "Welcome to the audio API" (12 words)\nEstimated tokens: 24'},
      {label: '422 Validation Error', language: 'json', code: validationError},
    ],
  },
];

function TableCard({title, rows, headerLabels}) {
  return (
    <div className={styles.tableCard}>
      <h4>{title}</h4>
      <table>
        <thead>
          <tr>
            {headerLabels.map(label => (
              <th key={label}>{label}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {rows.map(row => (
            <tr key={row.name}>
              <td><code>{row.name}</code></td>
              <td>{row.type}</td>
              <td>{row.defaultValue}</td>
              <td>{row.description}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

function OutputCard({rows}) {
  return (
    <div className={styles.tableCard}>
      <h4>Outputs</h4>
      <table>
        <thead>
          <tr>
            <th>Status</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          {rows.map(row => (
            <tr key={row.name}>
              <td><code>{row.name}</code></td>
              <td>{row.type}</td>
              <td>{row.defaultValue}</td>
              <td>{row.description}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

function EndpointSection({endpoint}) {
  const [copied, setCopied] = useState(false);
  const copyValue = `${endpoint.method} ${TTS_BASE_URL}${endpoint.path}`;

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(copyValue);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      setCopied(false);
    }
  };

  return (
    <section id={endpoint.anchor} className={styles.endpointSection}>
      <div className={styles.endpointHeader}>
        <MethodBadge method={endpoint.method} />
        <code className={styles.endpointPath}>{endpoint.path}</code>
        <button type="button" className={styles.copyButton} onClick={handleCopy}>
          {copied ? 'Copied!' : 'Copy API'}
        </button>
      </div>
      <h3 className={styles.anchorTitle}>{endpoint.title}</h3>
      <p>{endpoint.description}</p>
      {endpoint.notes?.length > 0 && (
        <div className={styles.callout}>
          <strong>Implementation notes</strong>
          <ul>
            {endpoint.notes.map(note => (
              <li key={note}>{note}</li>
            ))}
          </ul>
        </div>
      )}
      <div className={styles.ioGrid}>
        <TableCard
          title="Inputs"
          rows={endpoint.inputs}
          headerLabels={['Name', 'Type', 'Default', 'Description']}
        />
        <OutputCard rows={endpoint.outputs} />
      </div>
      {endpoint.examples?.length > 0 && (
        <div className={styles.responseExamples}>
          {endpoint.examples.map(example => (
            <div key={example.label} className={styles.responseExampleCard}>
              <h4>{example.label}</h4>
              <CodeBlock language={example.language}>{example.code}</CodeBlock>
            </div>
          ))}
        </div>
      )}
    </section>
  );
}

export default function TtsPage() {
  return (
    <DocsLayout
      title="Audio Platform API"
      description="Text-to-speech service overview"
      sidebarSections={[
        {
          title: 'Overview',
          links: [
            {label: 'Introduction', to: '/'},
            {label: 'Text-to-Speech', to: '/tts'},
            {label: 'Speech-to-Text', to: '/stt'},
          ],
        },
        {
          title: 'TTS Service',
          links: [
            {label: 'Introduction', targetId: 'tts-introduction'},
            {label: 'Shared Payload', targetId: 'tts-shared-payload'},
            {label: 'POST /v1/audio/speech', targetId: 'tts-post-v1-audio-speech', method: 'POST'},
            {label: 'POST /v1/audio/speech/file', targetId: 'tts-post-v1-audio-speech-file', method: 'POST'},
            {label: 'POST /v1/audio/speech/preview', targetId: 'tts-post-v1-audio-speech-preview', method: 'POST'},
          ],
        },
        {
          title: 'STT Service',
          links: [
            {label: 'Introduction', to: '/stt'},
            {label: 'POST /stt/transcribe', to: '/stt'},
          ],
        },
      ]}
      integration={{
        title: 'Quick Integration',
        description: 'Authenticate and send your first synthesis request with a language of your choice.',
        defaultLanguage: 'python',
        languages: [
          {
            id: 'python',
            label: 'Python',
            language: 'python',
            code: `import requests

url = "${TTS_BASE_URL}/v1/audio/speech"
payload = {
    "text": "Hello world from INDUSLABS",
    "voice": "tara",
    "response_format": "mp3",
    "stream": False
}
response = requests.post(url, json=payload)
response.raise_for_status()
with open("hello.mp3", "wb") as audio_file:
    audio_file.write(response.content)
`,
          },
          {
            id: 'node',
            label: 'JavaScript (Node)',
            language: 'javascript',
            code: `import {writeFile} from 'fs/promises';
import fetch from 'node-fetch';

const payload = {
  text: 'Hello world from INDUSLABS',
  voice: 'tara',
  response_format: 'mp3',
  stream: false,
};

const response = await fetch('${TTS_BASE_URL}/v1/audio/speech', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(payload),
});
if (!response.ok) throw new Error('Request failed');
const audioBuffer = Buffer.from(await response.arrayBuffer());
await writeFile('hello.mp3', audioBuffer);
`,
          },
          {
            id: 'curl',
            label: 'cURL',
            language: 'bash',
            code: `curl -X POST "${TTS_BASE_URL}/v1/audio/speech" \\
  -H "Content-Type: application/json" \\
  -d '{"text": "Hello world from INDUSLABS", "voice": "tara"}'
`,
          },
        ],
      }}
    >
      <section id="tts-introduction" className={styles.pageIntro}>
        <h1>Text-to-Speech Service</h1>
        <p>
          Deliver natural-sounding speech with configurable voices, streaming playback, and file-based output.
          All endpoints share a consistent payload so you can reuse the same integration across streaming and
          download workflows.
        </p>
      </section>
      <section id="tts-shared-payload" className={styles.sectionHeading}>
        <h2>Shared Request Payload</h2>
        <p>
          Use the same JSON schema for every text-to-speech endpoint. Override specific fields (such as
          response_format or stream) depending on the output you need.
        </p>
      </section>
      <div className={styles.payloadCard}>
        <CodeBlock language="json">{sharedPayload}</CodeBlock>
      </div>
      <div className={styles.tableCard}>
        <h3>Payload Fields</h3>
        <table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Type</th>
              <th>Default</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            {sharedInputs.map(field => (
              <tr key={field.name}>
                <td><code>{field.name}</code></td>
                <td>{field.type}</td>
                <td>{field.defaultValue}</td>
                <td>{field.description}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
      {endpoints.map(endpoint => (
        <EndpointSection key={endpoint.anchor} endpoint={endpoint} />
      ))}
    </DocsLayout>
  );
}
